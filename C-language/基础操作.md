# 1. ！(x)

对于x ，非0为真，0为假。
# 2. 指针

# 3. switch

必须有break, 否则就是每一个case都会执行

```C
switch()
{
	case 1:printf("a");
	break;
}
```

# 4. 指针数组

## &/* 的对比
### & 是取地址的符号
&a对于获取a的存储地址
```C
int a;
printf("%d\n",&a);
// 是对于a取地址
```  
### * 是对于数据间接取值的符号，即对于地址进行取值的符号
p的存储值为arr[1]数据存储的地址
\*p 是对于p存储的地址的取值，即间接取值的符号
```C

int p = &arr[1];
printf("%d\n", *p);
```


## 用指针交换两个字符串的内容

### 原理：指针的内容存储的是数据的地址，交换数据的地址即可

```C
char *str1 ="hello";
char *str2 = "world";

str1内存储的是h的地址
str2内存储的是w的地址
// 设计函数只用改变str1与str2的内容即可
// 传入str1与str2的地址
void swape(char** str1, char** str2)
{
// 函数内的str1 与str2代表原参数的地址
// str1 = &str1;
// str2 = &str2;
	char* temp = *str1;
	*str1 = *str2;
	*str2 = temp;
}

```
# 5. 符号关系

## 连不等式

### a\<b\<c

等于(a<b)\<c,即a\<b的结果，0/1，与C进行比值

### p[1] = \*p - 1 + (p[-1] = 3);

先进行赋值操作 p[-1] = 3；然后获得3
然后进行整体的加减法

# 6. const的用法

const 限定指定的后面的元素不可改

```C
1. 指针的内容不可改变
const int *a = 10;

2. 指针指向的地址不可改变
int * const b  = 10;

3. 指针指向的地址与地址的内容都不可以改变
const int * const c = 10;

```

# 7. 输入数据

## 7.1 输入数据与定义数据类型不一

### 7.1.1 定义 int 输入float

会出现结果为一个很大的int数据
### 7.1.2 定义float 输入int

会出现一个0.0000


# 8. 内存分配与回收

## 8.1 动态分配与回收
### 8.1.1 malloc动态分配

### 8.1.2 free回收分配的内存


# 9. C语言的特点
## 1.使用指针：高效寻址
对于指针的理解简单点可以认为类似于汇编中的寻址方式，正是指针的存在使C语言威力无穷。有些程序用其他语言也可以实现，但C能够更有效地实现；有些程序无法用其它语言实现，如直接访问硬件，但C却可以。正因为指针可以拥有类似于汇编的寻址方式，所以可以使程序更高效。
## 2.使用宏函数：预装完整程序，运行时更加高效
函数和宏函数的区别就在于，宏函数占用了大量的空间，而函数占用了
时间。函数调用是要使用系统的栈来保存数据的，如果编译器里有栈检查选项，一般在
函数的头会嵌入一些汇编语句对当前栈进行检查；同时，CPU也要在函数调用时保存和
恢复当前的现场，进行压栈和弹栈操作，所以，函数调用需要一些CPU时间。而宏函数
不存在这个问题。宏函数仅仅作为预先写好的代码嵌入到当前程序，不会产生函数调用，
所以仅仅是占用了空间，而使程序可以高效运行。在频繁调用同一个宏函数的时候，该
现象尤其突出。
## 3.使用位操作：更基础的操作
位操作可以减少除法和取模的运算。在计算机程序中数据的位是可以操作的最小数据单位，理论上可以用"位运算"来完成所有的运算和操作。一般的位操作是用来控制硬件的，或者做数据变换使用，但是，灵活的位操作可以有效地提高程序运行的效率。

## 4.循环嵌套中将较长循环设为内存循环，较短循环设为外置循环，以减少cpu跨切循环层的次数，提高程序的运行效率


# 10.C语言的各种类型放置的区域

## 局部变量：栈区
栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

- **总结**：内存分配，是通过从后往前对于变量进行分配，从高地址往低地址分配的，数据的数据地址是从低到高连续的。
## 局部静态变量：静态区
全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后由系统释放
## 全局变量：静态区的常量区

## 全局静态变量：静态区

## 堆区
堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。

## 文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放

## 程序代码区—存放函数体的二进制代码。

## 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。


# 11. C语言的隐式转换
在C语言中，隐式类型转换（也称为自动类型转换）是指编译器在表达式中自动将一种数据类型转换为另一种数据类型的过程。以下是四种常见的隐式转换情况及其转换规则：
### 1. **算术转换（Arithmetic Conversion）**
   - **情况**：当表达式中包含不同类型的操作数时，编译器会自动将较低级别的类型转换为较高级别的类型，以便进行运算。
   - **转换规则**：
     1. **整数提升（Integer Promotion）**：如果操作数是`char`、`short`或`int`类型，且其值可以被`int`表示，则将其提升为`int`。如果`int`无法表示其值，则提升为`unsigned int`。
     2. **类型提升（Type Promotion）**：如果操作数是`float`，则将其提升为`double`。
     3. **类型转换（Type Conversion）**：如果操作数是`int`和`double`，则`int`会被转换为`double`。
     4. **无符号优先（Unsigned Precedence）**：如果操作数中有一个是无符号类型，则另一个操作数会被转换为无符号类型。

   **示例**：
   ```c
   int a = 5;
   double b = 3.14;
   double result = a + b;  // a被隐式转换为double
   ```

### 2. **赋值转换（Assignment Conversion）**
   - **情况**：当将一个值赋给一个不同类型的变量时，编译器会自动将右侧的值转换为左侧变量的类型。
   - **转换规则**：
     1. *整数到浮点数：如果左侧是浮点类型，右侧是整数类型，则整数会被转换为浮点数。
     2. ***浮点数到整数***：如果左侧是整数类型，右侧是浮点类型，则浮点数会被截断为整数（小数部分丢失）。
     3. **缩小转换（Narrowing Conversion）**：如果左侧类型的范围小于右侧类型，可能会导致数据丢失。

   **示例**：
   ```c
   int a = 10;
   double b = 3.14;
   a = b;  // b被隐式转换为int，a的值为3
   ```

### 3. **函数调用转换（Function Call Conversion）**
   - **情况**：当函数调用时，传递给函数的实参类型与函数声明中的形参类型不匹配时，编译器会自动进行类型转换。
   - **转换规则**：
     1. **整数提升**：如果形参是`int`，而实参是`char`或`short`，则实参会被提升为`int`。
     2. **浮点提升**：如果形参是`double`，而实参是`float`，则实参会被提升为`double`。
     3. **指针转换**：如果形参是指针类型，而实参是数组或函数，则数组或函数会被转换为指针。

   **示例**：
   ```c
   void func(double d);
   int main() {
       int a = 10;
       func(a);  // a被隐式转换为double
       return 0;
   }
   ```

### 4. **条件表达式转换（Conditional Expression Conversion）**
   - **情况**：在条件表达式（三元运算符 `? :`）中，如果两个操作数的类型不同，编译器会自动进行类型转换。
   - **转换规则**：
     1. **算术转换**：如果两个操作数都是算术类型，则按照算术转换规则进行转换。
     2. **指针转换**：如果一个操作数是指针，另一个是`NULL`或`0`，则`NULL`或`0`会被转换为指针类型。
     3. **void指针转换**：如果一个操作数是`void*`，另一个是指针类型，则另一个指针会被转换为`void*`。

   **示例**：
   ```c
   int a = 10;
   double b = 3.14;
   double result = (a > 5) ? a : b;  // a被隐式转换为double
   ```

### 总结
隐式类型转换在C语言中非常常见，理解这些转换规则有助于避免潜在的错误和数据丢失。在进行复杂的表达式计算时，务必注意类型的隐式转换，以确保程序的正确性。


